◆변수
 * 변수
   - 데이터를 저장하기 위한 공간
   - 값이 바뀔 수 있다
 * 변수 선언 방법
   - 타입 변수명 = 초기값;
 * 기본 타입(기본 자료형)
   - 정수 : byte, short, int, long
	- long형 리터럴 상수에는 접미사 L
   - 문자 : char
   - 실수 : float, double
	- 소수점 자리 : 정확도
	- 표현 범위
	- float형 리터럴 상수에는 접미사 f
   - 논리 : boolean
 * 자료형 변환
   - 변수/상수의 자료형을 일시적으로 변환
   - 자동
	- 정수 => 실수
	- 작은 바이트 => 큰 바이트
   - 강제(명시적)
	- 자동으로 안되는 경우
	- 상황에 따라서 자동으로 되는 상황이지만 필요에 의해 강제로 하는 경우도 있음 => / 연산할 때
 * 변수명 작성 규칙
   - 숫자가 첫글자가 될 수 없음
   - 특수문자는 _ 또는 $만 가능
   - 변수명 중복 선언 불가
   	- 필드와 지역변수는 중복될 수 있다.
 	  => 필드는 this.필드명으로 지역변수와 구분하여 접근할 수 있기 때문에
	- 같은 범위에서 동일한 이름을 가진 지역 변수를 선언할 수 없음
   - 대소문자 구별
 * 변수명 작성 관례
   - 카멜 표기법
	- 변수명을 소문자로 작성하고, 여러 단어로 된 변수명인 경우 두번째 단어부터 첫 글자만 대문자로 작성
	- 클래스/인터페이스/열거형명을 소문자로 작성하고, 첫번째 단어부터 첫 글자만 대문자로 작성
   - 변수명은 의미있게
	- 구글 번역, 네이버 사전을 통해

 * 상수
   - 리터럴 상수
	- 1, '1', "1", true
	- 리터럴 상수를 저장하는 공간이 따로 있어서 리터럴 상수가 언급되면 사용
	- 문자열인 경우 같은 리터럴 문자열을 저장하는 문자열 객체들은 같은 주소를 공유
	  String str1 = "hi";
	  String str2 = "hi";  //str1과 str2는 같은 주소를 저장(String 의 특징!)
   - 상수 변수
	- 변수 앞에 final 키워드가 붙어서 상수로 만듬
	- 값이 바뀔 수 없다
	- 지역 변수인 상수는 선언과 동시에 초기화를 반드시 해야 함
	- 필드인 상수는 생성자에서 초기화 할 수 있음

 * 변수 종류
   - 지역변수 : 메소드 안에서 선언 된 변수, 메소드를 빠져 나가면 사라짐
   - 필드 : 클래스의 멤버 변수
   - 매개 변수 : 메소드를 실행할 때 필요한 변수들, 메소드를 빠져 나가면 사라짐.
   - 참조 변수 : 객체, 열거형 등을 저장하는 변수, 기본 자료형이 아닌 변수들
   - 클래스 필드(변수) : static이 붙은 필드들, 동일한 클래스의 객체들이 공유하는 변수
   - 인스턴스(객체) 필드(변수) : static이 안붙은 필드들, 객체마다 필드가 존재
class Field {	
   static int classVar = 10; //클래스 변수 선언    -> 동일한 클래스의 객체 100개를 만들시 결국 서로 공유하기 때문에, 하나의 공간만 만들어짐. 값을 유지.
   int instanceVar = 20;    //인스턴스 변수 선언  -> 객체마다 필드가 존재하기 때문에, 100개를 만들기 100개의 공간이 만들어짐. 
					   인스턴스마다 가져야 하는 고유한 값을 유지하기 위해 사용
}

 * 매개변수와 인자
   - 매개변수는 메소드 선언부에 있는 변수
   - 인자는 메소드를 호출하기 위해 넘겨준 값(변수/상수) 

◆연산자
 *대입 : =, 오른쪽 값을 왼쪽에 저장
	=> == 와 혼동하지 말자!
 * 산술 : +, -, *, /, %
   - 정수 연산자 정수 => 정수
	- 특히 /(나누기) 조심. 1/2는 0.5가 아닌 0
   - /와 %는 두 번째 피연산자가 0이면 안 됨 => ArithmeticException 발생
 * 비교 : 크기 비교
   - <=를 =<로, >=를 =>로 잘못 쓰지 말자!
   - 참/거짓 => 조건식
 * 논리 : &&, ||, !
   - && : ~이고, 하고, 둘 다 참이면 참(나머지 모두 거짓)
   - || : ~이거나, 둘 다 거짓이면 거짓(나머지 모두 참)
   - ! : 반대
   - 조건식
 * 증감연산자 : ++, --
   - 전위 : 증가하고 동작('ㅈ ㅈ'으로 외우자)
   - 후위 : 동작하고 증가
 * 조건선택 연산자 : 꼭 알필요는 없지만 잘 사용하면 코드가 깔끔해진다.
	=> 조건식으로 대체가 가능
   조건식 ? 참일 때 : 거짓일 때;

◆제어문
 * if문
   - 모든 조건식은 if문으로 표현 가능
   - ~이면 ...한다
	~ : 조건식, ... : 실행문
   - 문법
if(조건식1) {	//조건식1이 참이면 실행문1을 실행
     실행문1;	
} else if(조건식2) {  //조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행
     실행문2;
} else {		//조건식1이 거짓이고 조건식2가 거짓이면 실행문 3을 실행
     실행문3;
}
	- if문 : 필수
	- else if문 : 0개 이상
	- else : 0개 또는 1개
	- if : ~이면
	- else : 위 조건식들이 모두 거짓이다.
if(조건식1) {	
     실행문1;	
} else {  
      if(조건식2){
	실행문2;
      } else {
	실행문3;
      }   
}

 * switch문
   - if문에서 특정 상황이면 switch를 쓰는게 코드가 깔끔하다.
   - 변수에 저장된 값에 따라 다르게 실행되는 경우/특정 연산 결과가 제한적인 경우
   - 문법
switch(변수명/식) {
case 값1: //1, '1', "1" -> 가능 //1.23, true -> 불가능
   실행문1;
   break;
case 값2:
   실행문2;
   break;
default:
   실행문;
}
   - 값에는 문자, 정수, 문자열만 가능
   - break는 생략이 가능
   - default는 0개 또는 1

◆반복문
 * 반복문
   - 반복적인 작업을 규칙적으로 할 때 적용
	=> 반복횟수, 규칙성
	=> 반복횟수 => 초기화 + 조건식 + 증감식
	=> 규칙성 => 실행문
   - 문법
for(초기화; 조건식; 증감식) {
     실행문;
}

//초기화
while(조건식) {
     실행문;
     증감식;
}

do{
     실행문;
}while(조건식);

//향상된 fot문 => 전체 탐색
for( 변수 : 배열 또는 컬렉션) {
     
}

◆배열
 - 같은 타입의 변수들을 모아 놓은 것 + (같은 의미의 변수들을 모아 놓은 것)
 - 배열은 참조 변수이다. 주소를 저장한다.
	=> 할당된 배열이 있는 0번비의 주소를 저장
 * 배열 선언 방법
타입 [] 배열명1, 배열명2;  //둘 다 배열로 선언이 된다.
타입 배열명3[], 배열명4;   //3만 배열로 선언이 되고, 4는 변수로 선언이 된다. 
 * 배열 할당
배열명 = new 타입[크기];
 * 배열은 번지를 통해 접근 가능
 * 배열은 0번지부터 크기 -1번지까지
 * 배열 이용시 ArrayIndexOutOfBoundsException 조심
 * 배열의 크기는 length를 이용하여 알 수 있다.
 * 배열은 할당하면 각 번지에 있는 값들이 기본값으로 초기화가 된다.
   - 정수 : 0, 실수 : 0.0, 참조변수 : null, 문자 : '\u0000'
 * 배열은 왜 사용??
	=> 반복문을 이용하여 효율적으로 코딩할 수 있다.

◆메소드 
 * 하나의 기능을 모아놓은 코드
 * 입력정보 : 매개변수(parameter), 출력정보 : 리턴타입  (ex) 자판기 : 매개변수 1000원 -> 출력 1000원짜리 콜라
 * 매개변수(parameter) : 메소드를 실행하기 위해 꼭 필요한 정보.(메소드를 만들때 주의해서 설정!)

◆접근제한자
 * private : 나(자신 클래스)
 * default : 나(자신 클래스) + 같은 패키지  (#접근제한자를 쓰지 않으면 기본적으로 적용되는 접근제한자이다.)
 * protected : 나(자신 클래스) + 같은 패키지 + 자식 클래스
 * public : 전부

◆메소드 오버로딩
 * 동일한 메소드가 여러개 있는 것!
 * 메소드명 동일
 * 매개변수(parameter)는 갯수가 다르거나 타입이 달라야 한다.
 * 리턴타입/접근제한자는 상관 없다.

◆클래스(class)
 * '필드 + 메소드 + 생성자'로 이루어져 있다.
 * 필드 : 클래스를 나타내는 정보들.
	=> (ex)사람의 속성 : 이름, 나이, 주민번호 등), 학생 클래스는 이름, 학년, 반, 번호등의 정보들을 가지고 있다.
 * 생성자 : 필드를 초기화 하는 곳이다.
   - 리턴타입이 없음. void 아님.
   - 생성자 이름은 클래스명과 동일하게 지어야 한다.
 * 메소드(Method) : 클래스에서 실행하는 기능들
	=> 리모컨 클래스는 전원을 켜기/끄기 기능이 있다.

◆클래스의 특징
 * '캡슐화, 상속, 다형성' 이 대표적 특징이다.
 * 캡슐화 
   - 클래스의 메소드가 어떻게 구현됐는지 알 필요가 없다. 우리는 그냥 그 기능을 사용하면 된다. 
 * 상속
   - 자식에게 필드/메소드를 물려준다 => 코드의 재사용성이 좋아진다.
 * 다형성★(상속 다음에 나오는 개념)
   - 부모 클래스의 객체로 다양한 자식 클래스의 객체를 관리할 수 있는 것.
   - 객채의 다형성, 매개변수의 다형성
List<Board> boardList = new ArrayList<Board>();
List<Board> boardList = new LinkedList<Board>();

 ◆객체 생성
클래스명 객체명 = new 생성자();
 * 객체에서 메소드 호출
객체명.메소드명(매개변수들);	✭우리가 배운 내용들을 어떻게 활용하는지가 매우 중요하다!

product p = new Product("신발", "슬리퍼", 1000, 2000);
String type = p.getType();
if(type.equals("신발")) {

}   //↓위 코드를 한 줄로 바꾼다면 -> 한 줄로 깔끔하게 사용하는 것도 좋지만, 그것보다 이해하고 사용하는 것이 중요하다. 
					  때문에, 이해가 덜 됐다면 위에 처럼 나눠서 이해된 코드로 사용하는 것이 좋다. 
if(p.getType().equals("신발")) {

}
 
◆메소드 호출
 * 클래스 메소드(static) : 클래스를 통해 호출
클래스명.메소드명(매개변수들);
 * 인스턴스 메소드(객체 메소드)
클래스명 객체명 = new 생성자();
객체명.메소드명(매개변수들);	(static이 붙지 않는 인스턴스 메소드는 반드시 객체가 필요하다!)

◆상속
 * 부모 클래스의 필드/메소드를 물려 받는 것
 * 접근 제한자에 따라 접근하지 못하는 필드/메소드가 있을 수 있음
 * extends
class 자식클래스명 extends 부모클래스명 {

}
 * 자식 클래스는 부모 클래스 1개만 상속 받을 수 있다.
	=> 클래스 상속은 단일 상속. 하나의 부모한테만 물려 받을 수 있다. 여러 부모한테 물려 받을 수 없다!

◆메소드 오버라이딩
 * 부모 클래스에 있는 메소드를 재정의 하는 것
 * 메소드명이 동일
 * 매개변수 갯수와 타입이 동일
 * 리턴타입도 동일
 * 접근제한자는 부모 클래스의 메소드보다 같거나 넓어야 함(private>default>protected>public)
	=> 부모 클래스의 메소드가 public이면 자식이 오버라이딩할 때 privete으로 할 수 없음
 * 에외던지기(처리)도 조상 예외로 하는건 괜찮지만 좁아지면 안된다.
	=> 부모 클래스의 메소드가 RuntimeException이 발생하는데, 
	     자식이 오버라이딩할 때 ArithmeticException으로 좁힐 수 없다.

◆this와 super
 * this는 클래스 자신을 참조하는 변수
 * super는 부모 클래스의 객체를 참조하는 변수
 * this()는 클래스 자신의 다른 생성자를 호출
 * super()는 부모 클래스의 생성자를 호출

◆메소드와 this
 * 클래스의 메소드에서 this를 사용하는 경우
   - 항상 사용이 가능
   - 주로 매개변수명과 필드명이 같은 경우 구분을 하기 위해 this를 사용한다.
   - this라는 참조변수는 언제든지 메소드에서 사용이 가능한데, setter작성할 때 주로 사용한다. setter와 같이 메개변수명과 필드명이 같을 경우.

◆클래스의 형변환
 * 자동 : 자식 클래스의 객체를 부모 클래스의 참조변수가 관리(사용) (ex)큰 박스(자식)에 있는 것을 작은 박스(부모)만큼만 관리하는 것)
부모클래스 객체A = new 자식클래스생성자();
   - 객체A는 부모 클래스에 있는 메소드는 다 사용이 가능
   - 객체A는 자식 클래스에만 있는 메소드는 그냥 사용 불가
	=>((자식클래스명)객체A).메소드() -> 이처럼 형변환을 다시 해줘야 함.
 *강제 : 부모 클래스의 객체를 자식 클래스의 참조변수가 관리(사용)하는 경우인데, 조건부로 아래와 같은 경우만 가능!
부모클래스 객체B = new 자식클래스생성자(); -> 자식클래스의 생성자를 이용하여 객체를 생성
자식클래스 객체C = (자식클래스)객체B;	 -> 큰 박스를 가지고 있다가 작은 박스만큼만 사용하던 중에 다시 큰 박스를 사용하기 위해 변환하는 것!

◆기본 API
 * 래퍼클래스
   - 기본 자료형을 클래스로 만듬.
   - byte -> Byte, short -> Short, int -> Integer, long -> Long
   - char -> Charater
   - float -> Float, double -> Double
   - 왜?
	- 재네릭 클래스는 < > 안에 클래스명이 필요하기 때문이다. 기본 자료형으로는 < > 안에 들어갈 수 없다.
	=> 기본 자료형을 사용할 수 없음.
	=> 기본 자료형을 대체할 수 있는 래커 클래스를 이용해야 함!
   - 박싱 : 기본 자료형 => 래퍼클래스의 객체로
   - 언박싱 : 래퍼클래스의 객체 => 기본 자료형으로
   - 래퍼 클래스 객체 사용시 null 체크!
Integer i1 = null;
int num1 = i1;   => int 기본 자료형에는 null을 저장할 수(넣을 수) 없다. 

 * String 
   - 문자열 클래스
   - String 객체에 값을 수정하면 문자열이 교체된다.
String str = "123";
str = "1234";
   - 위 코드에서 문자열 123 뒤에 4를 추가하는 것이 아니라 1234라는 문자열을 새로 만들어 주소를 가져온다.
   - length() : 문자열의 길이.
   - substring(int start, int end) : start번지부터 end-1번지까지 부분 문자열을 리턴.
   - charAt(int index) : index번지에 있는 문자열을 가져온다.
   - split(구분자) : 구분자를 기준으로 문자열들을 추출하여 문자열 배열을 리턴.
"A, B, C".split(",") => 0번지 : A, 1번지 : B, 2번지 : C
   - indexOf("문자열") : 문자열이 있으면 시작번지를 없으면 -1을 리턴.
   - toUpperCase() : 문자열을 대문자로
   - toLowerCase() : 문자열을 소문자로

 * Date(샘플코드는 꼭 기억해두자!)
   - 날짜 정보를 관리하는 클래스
   - Date -> 문자열로 14일차 패키지 확인
   - 문자열 -> Date로 14일차 패키지 확인

 * Math
   - min(int num1, int num2) : num1과 num2중 작은 수를 리턴
   - max(int num1, int num2) : num1과 num2중 큰 수를 리턴
   - abs(int num) : 절대값
   - round(double num) : 반올림(소수점 첫번째 자리)
   - floor(double num) : 버림(소수점 첫번째 자리)
   - ceil(double num) : 올림(소수점 첫번째 자리)
   - pow(a, b) : a의 b제곱
   - sqrt(a) : 루트 a

 * StringTokenizer : 구분자를 기준으로 문자열들을 가져와서 확인해주는 클래스
   - String 클래스의 split와 유사
   - countTokens() : 현재 토큰의 개수
   - hasMoreTokens() : 토큰이 더 있는지 '참/거짓'으로 알려줌
   - nextToken() : 다음 토큰
   
 * Object #상속과 관련된 부분
   - 모든 클래스의 최상위 조상클래스
	=> 모든 클래스는 Object클래스에 있는 메소드를 가지고 있다.
	=> 오버라이드를 통해 재정의 할 수 있다.
   - equals() : 
	- Object클래스의 equals는 주소가 같은 객체인 경우만 true
	- 객체의 필드들이 같더라도 같은 주소의 객체가 아니라면 false
	- 오버라이딩을 이용하여 필드가 같으면 같은 객체로 판별하도록 작성
   - toString() : 
	- 패키지명과 클래스명과 @주소가 나옴
	- 객체를 통해 간단히 필드들을 확인할 때 오버라이딩하여 사용

◆추상메소드
 * 메소드 구현부가 없는 메소드
 * 오버라이딩이 필요한 메소드

◆추상클래스
 * 추상메소드가 0개이상 있는 메소드
 * 키워드로 abstract가 필요
 * 추상메소드에는 반드시 abstract를 추가해야 함
 * 추상클래스를 상속받은 자식 클래스를 생성한 후, 추상 메소드들을 오버라이딩하여 객체를 생성

◆인터페이스
 * 추상메소드와 클래스상수필드(final static)로 구성
 * 메소드에 abstract를 생략해도 자동으로 추가 됨 + public
 * 구현 클래스를 생성한 후, 추상 메소드들을 오버라이딩하고 객체를 생성

◆예외 처리
 * 직접 처리
   - try ~ catch
try{
   예외가 발생할 수 있는 코드;
}catch(예외클래스1 e) {
   예외처리;
}catch(예외클래스2 e) {
   예외처리;
}
   - 예외클래스1과 예외클래스2의 관계
	-> 예외클래스2가 예외클래스1의 조상클래스이거나 자식이 아닌 예외 클래스가 와야 한다.
	-> 예외클래스2에 예외클래스1의 자손클래스가 오면 에러가 발생
 * 예외 던지기
   - throw 
	-> 조건문과 같이 사용
	-> throw new 예외클래스명(예외메세지);
   - throws
	-> throw를 이용하는 경우 메소드에 예외가 발생할 수 있다는 것을 표시할 때 사용
	-> 매개변수 옆에 표시
	-> RuntimeException이거나 자손클래스이면 생략 가능, 아니면 생략 불가능
 * 예외캘르스 종류
   - ArithmeticException : 0으로 나눌 때 발생
   - ArrayIndexOutOfBoundsException : 배열의 범위를 벗어날 때 발생
   - NegativeArraySizeException : 배열의 크기를 음수로 했을 때 발생
   - NullPointerException : null인 객체의 필드나 메소드에 접근하려고 했을 때
   - ClassCastException : 클래스변환에 실패했을 때 
   - FileNotFoundException : 파일을 찾을 수 없을 때 

◆컬렉션 프레임워크
 * 데이터를 효율적으로 관리하기 위한 것
 * 컬렉션
   - 공통
	- add(E e) : 요소 추가하고 true/false 리턴
	- remove(E e) : 요소 제거하고 true/false 리턴
	- size() : 크기
	- isEmpty : 비었으면 true 아니면 false
	- Iterator를 이용하여 하나씩 반복하여 요소를 꺼낼 수 있다.
   - 리스트
	- get(int index) : index 번지 요소 리턴
	- set(int index, E e) : index번지 요소를 e로 수정
	- remove(int index) : index번지 요소를 제거하고 성공하면 제거한 객체 리턴
   - 셋
	- 리스트와 셋은 향상된 for문을 이용하여 접근할 수 있다. 
   - 맵
	- key와 value로 이루어짐
	- key는 중복 불가
	- value는 중복 가능
	- put(K key, V value) : key와 value를 map에 추가
	- get(K key) : key와 일치하는 value를 반환
	- set(K key, V value) : key와 일치하는 객체에 value로 수정
	- keySet() : key와 value값들을 key와 value로 구성된 Entry 클래스 객체들을 set에 저장하여 반환
	- 반복문 활용(전체 탐색)
	  1.keySer()을 이용하여 key값들을 이용하여 get으로 가져온다. Iterator
	  2.entrySet()을 이용하여 Entry클래스 객체를 가져오고 Entry클래스 객체의 key와 value 값을 활용. Iterator

◆서버 클라이언트
 * 서버소켓 생성 소켓 생성
 * bind를 통해 포트와 IP주소를 연결 connect를 통해 서버 IP주소와 포트를 연결하여 연결 요청
 * accept()을 통해 요청이 올때까지 대기
 * 클라이언트 요청하여 수락
 * 공통 : InputStream, OutputStream을 통해 연결하여 데이터를 주고 받으면 된다. 이때, 쓰레드를 이용해야 다중 접속이 가능.
 * 파일은 열었으면 close()로 닫아야 함!
 * InputStream : 읽기 모드, 파일이 없으면 예외 발생
 * OutputStream : 쓰기 모드, 파일이 없으면 새로 생성
   - 있으면 덮어쓰기
   - 있으면 이어쓰기 : 파일을 열때 파일명 옆에, true를 추가(Ex)("text.txt", true); 

