◆변수
 * 변수
   - 데이터를 저장하기 위한 공간
   - 값이 바뀔 수 있다
 * 변수 선언 방법
   - 타입 변수명 = 초기값;
 * 기본 타입(기본 자료형)
   - 정수 : byte, short, int, long
	- long형 리터럴 상수에는 접미사 L
   - 문자 : char
   - 실수 : float, double
	- 소수점 자리 : 정확도
	- 표현 범위
	- float형 리터럴 상수에는 접미사 f
   - 논리 : boolean
 * 자료형 변환
   - 변수/상수의 자료형을 일시적으로 변환
   - 자동
	- 정수 => 실수
	- 작은 바이트 => 큰 바이트
   - 강제(명시적)
	- 자동으로 안되는 경우
	- 상황에 따라서 자동으로 되는 상황이지만 필요에 의해 강제로 하는 경우도 있음 => / 연산할 때
 * 변수명 작성 규칙
   - 숫자가 첫글자가 될 수 없음
   - 특수문자는 _ 또는 $만 가능
   - 변수명 중복 선언 불가
   	- 필드와 지역변수는 중복될 수 있다.
 	  => 필드는 this.필드명으로 지역변수와 구분하여 접근할 수 있기 때문에
	- 같은 범위에서 동일한 이름을 가진 지역 변수를 선언할 수 없음
   - 대소문자 구별
 * 변수명 작성 관례
   - 카멜 표기법
	- 변수명을 소문자로 작성하고, 여러 단어로 된 변수명인 경우 두번째 단어부터 첫 글자만 대문자로 작성
	- 클래스/인터페이스/열거형명을 소문자로 작성하고, 첫번째 단어부터 첫 글자만 대문자로 작성
   - 변수명은 의미있게
	- 구글 번역, 네이버 사전을 통해

 * 상수
   - 리터럴 상수
	- 1, '1', "1", true
	- 리터럴 상수를 저장하는 공간이 따로 있어서 리터럴 상수가 언급되면 사용
	- 문자열인 경우 같은 리터럴 문자열을 저장하는 문자열 객체들은 같은 주소를 공유
	  String str1 = "hi";
	  String str2 = "hi";  //str1과 str2는 같은 주소를 저장(String 의 특징!)
   - 상수 변수
	- 변수 앞에 final 키워드가 붙어서 상수로 만듬
	- 값이 바뀔 수 없다
	- 지역 변수인 상수는 선언과 동시에 초기화를 반드시 해야 함
	- 필드인 상수는 생성자에서 초기화 할 수 있음

 * 변수 종류
   - 지역변수 : 메소드 안에서 선언 된 변수, 메소드를 빠져 나가면 사라짐
   - 필드 : 클래스의 멤버 변수
   - 매개 변수 : 메소드를 실행할 때 필요한 변수들, 메소드를 빠져 나가면 사라짐.
   - 참조 변수 : 객체, 열거형 등을 저장하는 변수, 기본 자료형이 아닌 변수들
   - 클래스 필드(변수) : static이 붙은 필드들, 동일한 클래스의 객체들이 공유하는 변수
   - 인스턴스(객체) 필드(변수) : static이 안붙은 필드들, 객체마다 필드가 존재
class Field {	
   static int classVar = 10; //클래스 변수 선언    -> 동일한 클래스의 객체 100개를 만들시 결국 서로 공유하기 때문에, 하나의 공간만 만들어짐. 값을 유지.
   int instanceVar = 20;    //인스턴스 변수 선언  -> 객체마다 필드가 존재하기 때문에, 100개를 만들기 100개의 공간이 만들어짐. 
					   인스턴스마다 가져야 하는 고유한 값을 유지하기 위해 사용
}

 * 매개변수와 인자
   - 매개변수는 메소드 선언부에 있는 변수
   - 인자는 메소드를 호출하기 위해 넘겨준 값(변수/상수) 

◆연산자
 *대입 : =, 오른쪽 값을 왼쪽에 저장
	=> == 와 혼동하지 말자!
 * 산술 : +, -, *, /, %
   - 정수 연산자 정수 => 정수
	- 특히 /(나누기) 조심. 1/2는 0.5가 아닌 0
   - /와 %는 두 번째 피연산자가 0이면 안 됨 => ArithmeticException 발생
 * 비교 : 크기 비교
   - <=를 =<로, >=를 =>로 잘못 쓰지 말자!
   - 참/거짓 => 조건식
 * 논리 : &&, ||, !
   - && : ~이고, 하고, 둘 다 참이면 참(나머지 모두 거짓)
   - || : ~이거나, 둘 다 거짓이면 거짓(나머지 모두 참)
   - ! : 반대
   - 조건식
 * 증감연산자 : ++, --
   - 전위 : 증가하고 동작('ㅈ ㅈ'으로 외우자)
   - 후위 : 동작하고 증가
 * 조건선택 연산자 : 꼭 알필요는 없지만 잘 사용하면 코드가 깔끔해진다.
	=> 조건식으로 대체가 가능
   조건식 ? 참일 때 : 거짓일 때;

◆제어문
 * if문
   - 모든 조건식은 if문으로 표현 가능
   - ~이면 ...한다
	~ : 조건식, ... : 실행문
   - 문법
if(조건식1) {	//조건식1이 참이면 실행문1을 실행
     실행문1;	
} else if(조건식2) {  //조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행
     실행문2;
} else {		//조건식1이 거짓이고 조건식2가 거짓이면 실행문 3을 실행
     실행문3;
}
	- if문 : 필수
	- else if문 : 0개 이상
	- else : 0개 또는 1개
	- if : ~이면
	- else : 위 조건식들이 모두 거짓이다.
if(조건식1) {	
     실행문1;	
} else {  
      if(조건식2){
	실행문2;
      } else {
	실행문3;
      }   
}

 * switch문
   - if문에서 특정 상황이면 switch를 쓰는게 코드가 깔끔하다.
   - 변수에 저장된 값에 따라 다르게 실행되는 경우/특정 연산 결과가 제한적인 경우
   - 문법
switch(변수명/식) {
case 값1: //1, '1', "1" -> 가능 //1.23, true -> 불가능
   실행문1;
   break;
case 값2:
   실행문2;
   break;
default:
   실행문;
}
   - 값에는 문자, 정수, 문자열만 가능
   - break는 생략이 가능
   - default는 0개 또는 1

◆반복문
 * 반복문
   - 반복적인 작업을 규칙적으로 할 때 적용
	=> 반복횟수, 규칙성
	=> 반복횟수 => 초기화 + 조건식 + 증감식
	=> 규칙성 => 실행문
   - 문법
for(초기화; 조건식; 증감식) {
     실행문;
}

//초기화
while(조건식) {
     실행문;
     증감식;
}

do{
     실행문;
}while(조건식);

//향상된 fot문 => 전체 탐색
for( 변수 : 배열 또는 컬렉션) {
     
}

◆배열
 - 같은 타입의 변수들을 모아 놓은 것 + (같은 의미의 변수들을 모아 놓은 것)
 - 배열은 참조 변수이다. 주소를 저장한다.
	=> 할당된 배열이 있는 0번비의 주소를 저장
 * 배열 선언 방법
타입 [] 배열명1, 배열명2;  //둘 다 배열로 선언이 된다.
타입 배열명3[], 배열명4;   //3만 배열로 선언이 되고, 4는 변수로 선언이 된다. 
 * 배열 할당
배열명 = new 타입[크기];
 * 배열은 번지를 통해 접근 가능
 * 배열은 0번지부터 크기 -1번지까지
 * 배열 이용시 ArrayIndexOutOfBoundsException 조심
 * 배열의 크기는 length를 이용하여 알 수 있다.
 * 배열은 할당하면 각 번지에 있는 값들이 기본값으로 초기화가 된다.
   - 정수 : 0, 실수 : 0.0, 참조변수 : null, 문자 : '\u0000'
 * 배열은 왜 사용??
	=> 반복문을 이용하여 효율적으로 코딩할 수 있다.

◆메소드 
 * 하나의 기능을 모아놓은 코드
 * 입력정보 : 매개변수(parameter), 출력정보 : 리턴타입 
 * 매개변수(parameter) : 메소드를 실행하기 위해 꼭 필요한 정보.

◆접근제한자
 * private : 나(자신 클래스)
 * default : 나(자신 클래스) + 같은 패키지
 * protected : 나(자신 클래스) + 같은 패키지 + 자식 클래스
 * public : 전부

◆메소드 오버로딩
 * 동일한 메소드가 여러개 있는 것!
 * 메소드명 동일
 * 매개변수(parameter)는 갯수가 다르거나 타입이 달라야 한다.
 * 리턴타입/접근제한자는 상관 없다.

◆클래스(class)
 * '필드 + 메소드 + 생성자'로 이루어져 있다.
 * 필드 : 클래스를 나타내는 정보들.
	=> (ex)사람의 속성 : 이름, 나이, 주민번호 등), 학생 클래스는 이름, 학년, 반, 번호등의 정보들을 가지고 있다.
 * 생성자 : 필드를 초기화 하는 곳이다.
   - 리턴타입이 없음. void 아님.
   - 생성자 이름은 클래스명과 동일하게 지어야 한다.
 * 메소드(Method) : 클래스에서 실행하는 기능들
	=> 리모컨 클래스는 전원을 켜기/끄기 기능이 있다.

◆클래스
 * '캡슐화, 상속, 다형성' 이 대표적 특징이다.
 * 캡슐화 
   - 클래스의 메소드가 어떻게 구현됐는지 알 필요가 없다.
 * 상속
   - 자식에게 필드/메소드를 물려준다 => 코드의 재사용성이 좋아진다.
 * 다형성★
   - 부모 클래스의 객체로 다양한 자식 클래스의 객체를 관리할 수 있는 것.
   - 객채의 다형성, 매개변수의 다형성
List<Board> boardList = new ArrayList<Board>();
List<Board> boardList = new LinkedList<Board>();

 ◆객체 생성
클래스명 객체명 = new 생성자();
 * 객체에서 메소드 호출
객체명.메소드명(매개변수들);

product p = new Product("신발", "슬리퍼", 1000, 2000);
String type = p.getType();
if(type.equals("신발")) {

}   //↓위 코드를 한 줄로 바꾼다면
if(p.getType().equals("신발")) {

}
 
◆메소드 호출
 * 클래스 메소드(static) : 클래스를 통해 호출
클래스명.메소드명(매개변수들);
 * 인스턴스 메소드
클래스명 객체명 = new 생성자();
객체명.메소드명(매개변수들);

◆상속
 * 부모 클래스의 필드/메소드를 물려 받는 것
 * 저근 제한자에 따라 접근하지 못하는 필드/메소드가 있을 수 있음
 * extends
class 자식클래스명 extends 부모클래스명 {

}
 * 자식 클래스는 부모 클래스 1개만 상속 받을 수 있다.
	=> 클래스 상속은 단일 상속

◆메소드 오버라이딩
 * 부모 클래스에 있는 메소드를 재정의 하는 것
 * 메소드명이 동일
 * 매개변수 갯수와 타입이 동일
 * 리턴타입도 동일
 * 접근제한자는 부모 클래스의 메소드보다 같거나 넓어야 함
	=> 부모 클래스의 메소드가 public이면 자식이 오버라이딩할 때 privete으로 할 수 없음
 * 에외던지기도 조상 예외로 하는건 괜찮지만 좁아지면 안된다.
	=> 부모 클래스의 메소드가 RuntimeException이 발생하는데, 
	     자식이 오버라이딩할 때 ArithmeticException으로 좁힐 수 없다.

◆this와 super
 * this는 클래스 자신을 참조하는 변수
 * super는 부모 클래스의 객체를 참조하는 변수
 * this()는 클래스 자신의 다른 생성자를 호출
 * super(0는 부모 클래스의 생성자를 호출

◆메소드와 this
 * 클래스의 메소드에서 this를 사용하는 경우
   - 항상 사용이 가능
   - 주로 매개변수명과 필드명이 같은 경우 구분을 하기 위해 this를 사용한다.

◆클래스의 형변환
 * 자동 : 자식 클래스의 객체를 부모 클래스의 참조변수가 관리
부모클래스 객체A = new 자식클래스생성자();
   - 객체A는 부모 클래스에 있는 메소드는 다 사용이 가능
   - 객체A는 자식 클래스에만 있는 메소드는 그냥 사용 불가
	=>((자식클래스명)객체A).메소드()
 *강제 : 부모 클래스의 객체를 자식 클래스의 참조변수가 관리하는 경우인데, 조건부로 아래와 같은 경우만 가능!
부모클래스 객체B = new 자식클래스생성자();
자식클래스 객체C = (자식클래스)객체B;

◆기본 API
 * 래퍼클래스
   - 기본 자료형을 클래스로 만듬.
   - byte -> Byte, short -> Short, int -> Integer, long -> Long
   - char -> Charater
   - float -> Float, double -> Double
   - 왜?
	- 재네릭 클래스는 < > 안에 클래스명이 필요하기 때문이다. 기본 자료형으로는 < > 안에 들어갈 수 없다.
	=> 기본 자료형을 사용할 수 없음.
	=> 기본 자료형을 대체할 수 있는 래커 클래스를 이용해야 함!
   - 박싱 : 기본 자료형 => 래퍼클래스의 객체로
   - 언박싱 : 래퍼클래스의 객체 => 기본 자료형으로
   - 래퍼 클래스 객체 사용시 null 체크!
Integer i1 = null;
int num1 = i1;   => int 기본 자료형에는 null을 넣을 수 없다. 

◆String 
 * 문자열 클래스
 * String 객체에 값을 수정하면 문자열이 교체된다.
String str = "123";
str = "1234";
   - 위 코드에서 문자열 123 뒤에 4를 추가하는 것이 아니라 1234라는 문자열을 새로 만들어 주소를 가져온다.
 * length() : 문자열의 길이.
 * substring(int start, int end) : start번지부터 end-1번지까지 부분 문자열을 리턴.
 * charAt(int index) : index번지에 있는 문자열을 가져온다.
 * split(구분자) : 구분자를 기준으로 문자열들을 추출하여 문자열 배열을 리턴.
"A, B, C".split(",") => 0번지 : A, 1번지 : B, 2번지 : C
 * indexOf("문자열") : 문자열이 있으면 시작번지를 없으면 -1을 리턴.
 * toUpperCase() : 문자열을 대문자로
 * toLowerCase() : 문자열을 소문자로





