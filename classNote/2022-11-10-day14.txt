◆클래스
 - 하나의 정보를 표현하기 위해 여러 변수들과 기능들을 모아놓은 것
 - 필드, 메소드, 생성자로 구성된다.
	- 필드는 속성 또는 정보라고도 할 수 있으며 공통되고 필수인 정보를 말함.
		- 필드는 일반적으로 접근제한자가 private이다. => getter(값 불러옴)/setter(값 설정함) 필요
	- 메소드 : 필요한 기능, 대부분 필드 값을 변경되게 하는 기능
		- 메소드는 일반적으로 접근제한자가 public이다.
	- 생성자 : 필드 초기화
 
◆접근제한자
 - private		: 나
 - (default)	: 나, 같은 패키지 내 클래스
 - protected	: 나, 같은 패키지 내 클래스, 자식 클래스
 - public		: 나, 같은 패키지 내 클래스, 자식 클래스, 외부 클래스

 -  같은 이름의 클래스는 존재할 수 있다? 없다?
	- 같은 패키지내에서는 존재 할 수 없다.
	- 다른 패키지내에서는 존재 할 수 있다.

- public 클래스가 되기 위한 조건
	- 클래스명과 파일명이 동일

◆필드 초기화 순서
 - 클래스 필드 : 
	1. 필드의 기본값으로 초기화
	2. 명시적 초기화(선언과 동시에 초기화)
	3. 초기화 블록(static{} 안에 있는)

 - 인스턴스 필드 : 
	1. 필드의 기본값으로 초기화
	2. 명시적 초기화(선언과 동시에 초기화)
	3. 초기화 블록({} 안에 있는)
	4. 생성자

클래스 필드 : static이 붙은 필드
	- 클래스가 메모리에 올라오면 필드들이 할당
	- 객체들이 클래스 필드를 공유
인스턴스 필드 : static이 안붙은 필드
	- 객체가 생성될 때 필드들이 할당
	- 객체마다 인스턴스 필드를 가지고 있음

*사용범위
클래스 필드/메소드
 - 클래스 메소드에서 사용 가능? O
 - 인스턴스 메소드에서 사용 가능? O
 
인스턴스 필스/메소드
 - 클래스 메소드에서 사용 가능? X
	- 직접 사용은 불가능하지만 객체를 생성 후 사용하는 건 가능
 - 인스턴스 메소드에서 사용 가능? O 

◆상속
 - 부모 클래스의 필드 메소드를 물려 받아 자식 클래스가 활용하는 것
 - 접근제한자가 private인 필드/메소드는 직접 접근해서 사용할 수 없다.
 - 상속 하는 이유
	- 코드의 중복을 제거하기 위해
	- 다형성을 이용하여 메소드 중복을 제거하기 위해서

class 자식클래스명 extends 부모클래스명{	}

 - 클래스에서 부모 클래스는 몇개? 1개만 가능.
 - 인터페이스에서 부모 인터페이스는 몇개? 여러개 가능.


◆다형성 : 하나의 객체가 여러가지 타입을 가질 수 있는 것.
◆매개변수의 다형성
예)
public void 전원(Tv tv){}
public void 전원(에어컨 a){}
public void 전원(컴퓨터 b){}
=> public void 전원(전자제품 obj){} -> 매개변수로 여러 객체들이 올 수 있다. 이 때 매개변수로 오는 객체들이 동일한 조상 클래스의 자식 클래스들인 경우, 
				매개변수를 조상클래스의 객체로 선언하면 여러 메소드를 만들 필요가 없다. 
			        -> 조건은 Tv, 에어컨, 컴퓨터가 전자제품 클래스를 상속 받아야 함.


◆객체의 다형성
예)
Tv tv1, tv2, tv3;
컴퓨터 com1, com2, com3;
에어컨 에어컨1;
=> 위 코드에서는 다양한 클래스의 객체들을 하나로 관리할 수 없다. -> 전자제품 [] pro;


◆클래스 변환
 - 자동
	- 자식 객체 => 부모 객체에 저장
 - 강제
	- 부모 객체 => 자식 객체에 저장(조건부 가능 : 부모 객체와 연결된 객체가 자식 클래스 객체인 경우, 강제 클래스 변환이 가능)
	- 부모 객체와 연결된 객체가 부모 클래스 객체인 경우, 강제 클래스 변환이 불가능.


◆instanceof : 연산자, 클래스 변환이 가능한지 불가능한지 알려주는 연산자
 - 조건문과 같이 활용
 

◆인터페이스
 - 추상 메소드와 클래스 상수로만 이루어진 것
 - 기능들을 표준화, 기능 명세

 - 추상 메소드
	- 메소드 구현부가 없는 메소드
	- 기능을 사용하려면 메소드 오버라이딩을 통해 구현을 한 후 호출

 - 구현 클래스 : 인터페이스를 구현한 클래스
	- 인터페이스에 있는 메소드들을 반드시 오버라이딩 해야 한다.
 	- 구현 클래스는 여러 인터페이스를 구현할 수 있다.
예) class A implements InterfaceA, InterfaceB{}
	- 구현 클래스A는 인터페이스 InterfaceA와 InterfaceB를 구현한 구현 클래스이다.

 - 상속과 구현은 같이 할 수 있다.
예) class Child extends Parent implements InterfaceA{}


◆String 클래스
 - indexOf(), equals(), length(), substring, split()


◆Object 클래스
 - equals(), toString()


◆Wrapper 클래스 : 기본 자료형을 클래스로 만든 것
 - int -> Integer
 - boolean -> Boolean
 - char -> Charater
 - double -> Double




